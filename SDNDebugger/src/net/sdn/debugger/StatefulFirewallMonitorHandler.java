package net.sdn.debugger;

/**
 * @author Tomasz Bak
 * @author Da Yu, Yiming Li
 */
import java.util.ArrayList;
import java.util.LinkedList;

import net.sdn.packet.Event;
import net.sdn.packet.Packet;
import net.sdn.packet.EventGenearator;

import io.reactivex.netty.RxNetty;
import io.reactivex.netty.channel.ConnectionHandler;
import io.reactivex.netty.channel.ObservableConnection;
import io.reactivex.netty.pipeline.PipelineConfigurators;
import io.reactivex.netty.server.RxServer;
import rx.Notification;
import rx.Observable;
import rx.functions.Action0;
import rx.functions.Func1;

public class StatefulFirewallMonitorHandler implements Runnable {
	public void run() {
		createServer().startAndWait();
	}

	private final int port;
	// expectedEvents are events that expected to happened in the real network
	// generated by Oracle
	// based on the internal network state and the ideal model
	private LinkedList<Event> expectedEvents = new LinkedList<Event>();
	private LinkedList<Event> notExpectedEvents = new LinkedList<Event>();

	private static String lines = "";
	
	// lists for internal and external hosts
	private ArrayList<String> externalHosts = new ArrayList<String>();
	private ArrayList<String> internalHosts = new ArrayList<String>();
	
	// allowed flow
	private ArrayList<String> allowedFlow = new ArrayList<String>();
	
	// switch that connect with internal hosts
	private ArrayList<String> internalPort = new ArrayList<String>();
	private ArrayList<String> externalPort = new ArrayList<String>();
	
	private void loadHosts(){
		internalHosts.add("10.0.0.1");
		externalHosts.add("10.0.0.2");
	}
	
	private void loadTopoInfo(){
		internalPort.add("eth1");
		externalPort.add("eth2");
	}

	public StatefulFirewallMonitorHandler(int port) {
		this.port = port;
		loadHosts();
		loadTopoInfo();
		//loadAllowedFlow();
	}

	public RxServer<String, String> createServer() {
		RxServer<String, String> server = RxNetty.createTcpServer(port,
				PipelineConfigurators.textOnlyConfigurator(),
				new ConnectionHandler<String, String>() {
					@Override
					public Observable<Void> handle(
							final ObservableConnection<String, String> connection) {
						System.out.println("Monitor connection established.");
						return connection
								.getInput()
								.flatMap(
										new Func1<String, Observable<Notification<Void>>>() {
											@Override
											public Observable<Notification<Void>> call(
													String msg) {
												// set filters:
												lines += msg;
												String temp[] = lines
														.split("\n");
												
												char[] chs = lines
														.toCharArray();		
												int count = 0;
												
												if (chs[chs.length - 1] == '\n') {
													// full message line
													count = temp.length;
													lines = "";
												} else {
													// part message line							
													count = temp.length - 1;
													lines = temp[temp.length - 1];
												}
												
													for (int i = 0; i < count; i++) {
														// get pkt
														//System.out.println(temp[i]);
														Event eve = EventGenearator.deserialize(temp[i]);
														Packet pkt = eve.pkt;
														// set filter
														if ((pkt.nw_proto != null && pkt.nw_proto.equals("icmp")) || pkt.of_type >= 0){
															Oracle(eve);
														}

													}											

												return Observable.empty();
											}
										})
								.takeWhile(
										new Func1<Notification<Void>, Boolean>() {
											@Override
											public Boolean call(
													Notification<Void> notification) {
												return !notification.isOnError();
											}
										}).finallyDo(new Action0() {
									@Override
									public void call() {
										System.out.println(" --> Closing StatefulFireWall Monitor handler and stream");
									}
								}).map(new Func1<Notification<Void>, Void>() {
									@Override
									public Void call(
											Notification<Void> notification) {
										return null;
									}
								});
					}
				});

		System.out.println("StatefulFireWall Monitor handler started...");
		return server;
	}

	private void Oracle(Event eve) {
		// TODO: conflict between expectedList and NotExpectedList
		Packet pkt = eve.pkt;
		
		// if packet is an OF13 message but it is a heartbeat, ignore.
		// For current stage, ignore arp
		if (pkt.of_type >= 0 && ((pkt.of_type == 2 || pkt.of_type == 3) || (pkt.dl_proto != null && pkt.dl_proto.equals("arp")))){
			return;
		}
		
		//System.out.println(eve);
		
		// if packet is an ICMP packet, and the packet is sent from the host
		if (pkt.of_type <0 && pkt.nw_proto != null && pkt.nw_proto.equals("icmp")){
			
			// sent from internal hosts
			if (internalHosts.contains(pkt.nw_src) && internalPort.contains(eve.interf)){ 
				if (allowedFlow.contains(pkt.nw_dst)){
					// not first time, just await response
					System.out.println("Received ICMP packet from:" + eve.sw + ":" + eve.interf);
					// generate 
					//System.out.println("Expected: Received this ICMP packet at s1-eth2");
					Event event = new Event();
					event.pkt = pkt;
					event.sw = "s1";
					event.interf = "eth2";
					synchronized(expectedEvents){
						expectedEvents.add(event);
						System.out.println("*****************expectedEvents*****************");
						printEvents(expectedEvents);
					}
				} else {
					// first time receive icmp, procedures are required
					// open hole for return flow
					System.out.println("Received ICMP packet from:" + eve.sw + ":" + eve.interf);
					allowedFlow.add(pkt.nw_dst);
					allowedFlow.add(pkt.nw_src);
					synchronized(expectedEvents){
						generateExpectedEventsForFirstPacket(pkt);
						System.out.println("*****************expectedEvents*****************");
						printEvents(expectedEvents);
					}
				}
			// sent from external hosts
			} else if (externalHosts.contains(pkt.nw_src) && externalPort.contains(eve.interf)){
				if (allowedFlow.contains(pkt.nw_dst)){
					// return flow, pass through
					System.out.println("Received ICMP packet from:" + eve.sw + ":" + eve.interf);
					Event event = new Event();
					event.pkt = pkt;
					event.sw = "s1";
					event.interf = "eth1";
					synchronized(expectedEvents){
						expectedEvents.add(event);
						System.out.println("*****************expectedEvents*****************");
						printEvents(expectedEvents);
					}
				} else {
					// dropped by the firewall
					System.out.println("Received ICMP packet from:" + eve.sw + ":" + eve.interf);
					Event event1 = new Event();
					event1.pkt = pkt;
					event1.sw = "s1";
					event1.interf = "eth1";
					Event event2 = new Event();
					event2.pkt = pkt;
					event2.sw = "s1";
					event2.interf = "eth2";
					synchronized(notExpectedEvents){
						notExpectedEvents.add(event1);
						notExpectedEvents.add(event2);
						System.out.println("*****************notExpectedEvents*****************");
						printEvents(notExpectedEvents);
					}
				}	
			} else {
				verify(eve);
			}
		}
	}
	
	private void verify(Event e){
		//System.out.println(e);
		// check notExpectedEvent List
		synchronized(notExpectedEvents){
			for (Event notExpected : notExpectedEvents) {
				if (notExpected.equals(e)) {
					System.err.println("Not Expected Event Happened:");
					System.err.println(notExpected);
					return;
				}
			}
		}
		// check expectedEvent List
		synchronized(expectedEvents){
			for (Event expected : expectedEvents) {
				if (expected.equals(e)) {
					System.out.println("Expected Event Happened:");
					System.out.println(expected);
					return;
				}
			}
		}
		
		System.err.println("Unknown Event:");
		System.err.println(e);
		return;
	}
	
	private void generateExpectedEventsForFirstPacket(Packet p){
		// TODO: STILL GOT PROBLEM IN MONITOR
		
		// Event 1: this icmp packet will be sent to the controller
		Event event = new Event();
		Packet pkt = new Packet();
		pkt.of_type = 10; // PACKET_IN
		pkt.tp_dst_port = "6633"; // To the controller
//		pkt.dl_proto = "icmp";
//		pkt.nw_src = "127.0.0.1,10.0.0.1";
//		pkt.nw_dst = "127.0.0.1,10.0.0.2";
		event.pkt = pkt;
		event.sw = "s1";
//		System.out.println("Expected: Sent this ICMP packet to the controller");
		expectedEvents.add(event);
		
		// Event 2: 2 Flow_mod sent from the controller to s1
		event = new Event();
		pkt = new Packet();
		pkt.of_type = 14; // Flow_MOD
		pkt.tp_src_port = "6633";
//		pkt.nw_src = "127.0.0.1,10.0.0.1";
//		pkt.nw_dst = "127.0.0.1,10.0.0.2";
		event.pkt = pkt;
		event.sw = "s1";
//		System.out.println("Expected: Flow_Mod Sent from the controller");
		expectedEvents.add(event);
		event = new Event();
		pkt = new Packet();
		pkt.of_type = 14; // Flow_MOD
		pkt.tp_src_port = "6633";
//		pkt.nw_src = "127.0.0.1";
//		pkt.nw_dst = "127.0.0.1";
		event.pkt = pkt;
		event.sw = "s1";
//		System.out.println("Expected: Flow_Mod Sent from the controller");
		expectedEvents.add(event);
		
		// Event 3: ICMP packet sent from the controller
		event = new Event();
		pkt = new Packet();
		pkt.of_type = 13; // PACKET_OUT
		pkt.tp_src_port = "6633";
		event.pkt = pkt;
		event.sw = "s1";
//		System.out.println("Expected: ICMP packet sent from the controller");
		expectedEvents.add(event);
		
		// Event 4: ICMP packet received at s1-eth2
		event = new Event();
		event.pkt = p; 
		event.sw = "s1";
		event.interf = "eth2";
//		System.out.println("Expected: ICMP packet received at s1-eth2");
		expectedEvents.add(event);
	}
	
	// for test only
	private void printEvents(LinkedList<Event> lst){
		for (Event e : lst)
			System.out.println(e);
		System.out.println("***************************************");
	}
}
